/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package dijkstrasalgorithm;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import javax.swing.UIManager;

/**
 *
 * @author Julius
 */

public class DijkstrasAlgorithm extends javax.swing.JFrame {
    private static int rows = 0;
    private static int columns = 0;
    /**
     * Creates new form DijkstrasAlgorithm
     */
    public DijkstrasAlgorithm() {
        try{
        javax.swing.UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        initComponents();
        }catch(Exception e){
            e.printStackTrace();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel2 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(1150, 600));
        setSize(new java.awt.Dimension(1150, 600));

        jPanel2.setBackground(new java.awt.Color(204, 204, 204));
        jPanel2.setPreferredSize(new java.awt.Dimension(1150, 600));

        jPanel4.setPreferredSize(new java.awt.Dimension(560, 580));

        jLabel1.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jLabel1.setText("Начало пути");

        jTextField1.setFont(new java.awt.Font("Times New Roman", 0, 14)); // NOI18N
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jLabel2.setText("Конец пути");

        jTextField2.setFont(new java.awt.Font("Times New Roman", 0, 14)); // NOI18N
        jTextField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField2ActionPerformed(evt);
            }
        });

        jButton1.setText("Строим путь");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jTextArea1.setRows(5);

        jLabel3.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jLabel3.setText("Время расчёта пути: ");

        jLabel4.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(224, 224, 224)
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jTextField1)
                            .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jTextField2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(25, 25, 25)
                        .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, 502, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(38, 38, 38)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4)))
                .addContainerGap(33, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(80, 80, 80)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(38, 38, 38)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jTextArea1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(36, 36, 36)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addContainerGap(118, Short.MAX_VALUE))
        );

        jPanel5.setPreferredSize(new java.awt.Dimension(560, 580));

        jTable1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {" 1", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 2", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 3", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 4", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 5", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 6", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 7", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 8", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {" 9", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"10", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"11", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"12", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"13", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"14", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"15", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"16", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"17", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"18", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"19", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},
                {"20", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "", " 1", " 2 ", " 3", " 4", " 5", " 6", " 7", " 8", " 9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTable1.setGridColor(new java.awt.Color(0, 0, 0));
        jTable1.setRowSelectionAllowed(false);
        jTable1.setSelectionForeground(new java.awt.Color(0, 0, 0));
        jTable1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jTable1.getTableHeader().setResizingAllowed(false);
        jTable1.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(jTable1);
        if (jTable1.getColumnModel().getColumnCount() > 0) {
            jTable1.getColumnModel().getColumn(0).setResizable(false);
            jTable1.getColumnModel().getColumn(1).setResizable(false);
            jTable1.getColumnModel().getColumn(2).setResizable(false);
            jTable1.getColumnModel().getColumn(3).setResizable(false);
            jTable1.getColumnModel().getColumn(4).setResizable(false);
            jTable1.getColumnModel().getColumn(5).setResizable(false);
            jTable1.getColumnModel().getColumn(6).setResizable(false);
            jTable1.getColumnModel().getColumn(7).setResizable(false);
            jTable1.getColumnModel().getColumn(8).setResizable(false);
            jTable1.getColumnModel().getColumn(9).setResizable(false);
            jTable1.getColumnModel().getColumn(10).setResizable(false);
            jTable1.getColumnModel().getColumn(11).setResizable(false);
            jTable1.getColumnModel().getColumn(12).setResizable(false);
            jTable1.getColumnModel().getColumn(13).setResizable(false);
            jTable1.getColumnModel().getColumn(14).setResizable(false);
            jTable1.getColumnModel().getColumn(15).setResizable(false);
            jTable1.getColumnModel().getColumn(16).setResizable(false);
            jTable1.getColumnModel().getColumn(17).setResizable(false);
            jTable1.getColumnModel().getColumn(18).setResizable(false);
            jTable1.getColumnModel().getColumn(19).setResizable(false);
            jTable1.getColumnModel().getColumn(20).setResizable(false);
        }
        jTable1.getAccessibleContext().setAccessibleParent(jPanel5);

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 540, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 349, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 10, Short.MAX_VALUE)
                .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(10, 10, 10))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField1ActionPerformed

    private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField2ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        if(emptyTable()){
            if(jTextField1.getText().equals("") || jTextField2.getText().equals("")){
                JOptionPane.showMessageDialog(null, "Вы не ввели вершины для нахождения пути", "Путь",1);
            }else if(Integer.parseInt(jTextField1.getText())>rows || Integer.parseInt(jTextField2.getText())>rows || Integer.parseInt(jTextField1.getText())>columns || Integer.parseInt(jTextField2.getText())>columns){                       
                JOptionPane.showMessageDialog(null, "Неправильно задан путь", "Путь",1);
            }else{
                int[][] g = new int[rows][columns];
                for(int i = 0; i < rows; i++){
                    for(int j = 1; j < columns+1; j++){
                        g[i][j-1] = (int) jTable1.getModel().getValueAt(i, j);
                    }
                }
                long startTime = System.currentTimeMillis();
                jTextArea1.setText("Путь:\n"+len(Integer.parseInt(jTextField1.getText())-1,Integer.parseInt(jTextField2.getText())-1,g));
                long endTime = System.currentTimeMillis();
                jLabel4.setText((endTime - startTime)+" милисекунд");
            }
        }else{
            JOptionPane.showMessageDialog(null, "Матрица на заполнена или заполнена некорректно", "Матрица!",1);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    
    private boolean emptyTable(){
        columns = jTable1.getModel().getColumnCount()-1;
        rows = jTable1.getModel().getRowCount();
        int n = 0;
        
        for(int i = 0; i < jTable1.getModel().getRowCount(); i++){
            n=0;
            for(int j = 1; j < jTable1.getModel().getColumnCount(); j++){
                if(jTable1.getModel().getValueAt(i, j)==null){
                    n++;
                }
            }
            if(n==jTable1.getModel().getColumnCount()-1){
                rows--;
            }
        }
        n=0;
        
        for(int i=1;i<jTable1.getModel().getColumnCount();i++){
            n=0;
            for(int j=0;j<jTable1.getModel().getRowCount();j++){
                if(jTable1.getModel().getValueAt(j, i)==null){
                    n++;
                }
            }
            if(n==jTable1.getModel().getRowCount()){
                columns--;
            }
        }
        
        
        
        if(rows!=columns){
            return false;
        }else if(rows==0 && columns==0){
            return false;
        }else{
            for(int i=0;i<rows;i++){
                for(int j=1;j<columns;j++){
                    if(jTable1.getModel().getValueAt(j, i)==null){
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    public static String len(int begin, int end,int[][] g){
        int temp = 0;
        if(end<begin){                                                                                                  // так как пользователь может искать путь от большей к меньше вершине, могут возникнуть
            temp = end;                                                                                                 // проблемы при построении пути, для этого необходимо поменять их местами
            end = begin;
            begin = temp;
        }
        int[][] matr = new int[g.length][g.length];                                                                     // построение матрицы весов определенных вершин, в которые мы приходим из предыдущей вершины
        String path_ = "";                                                                                              // строка в которую будет записываться путь из матрицы
        String itog = "";                                                                                               // итоговый вариант пути, который будет предоставлен пользователю
        int end1 = end;                                                                                                 // сохранение в переменную, которая будет изменяться в цикле восстановления пути
        ArrayList<Integer> here = new ArrayList<>();                                                                    // список вершин, которые мы посетили (для чего и как можно изучить из самого алгоритма Дейкстры)
        int[] weight = new int[g.length];                                                                               // массив весов вершин, которые посетил алгоритм проходя от begin вершины к любрй другой вершине
        int[] path = new int[g.length];                                                                                 // массив в котором хранится путь, в ячейке хранится индекс этого же массива из которого мы пришли в эту ячейку
        int[][] p = new int[g.length][g.length];                                                                        // так как на каждом шаге вершина переходит в определенные вершину, матрица в каждой своей строке хранит в какие мы вершины переходим записывая на это место номер вершины из которой мы пришли
        here.add(begin);                                                                                                // записываем в список посещенных вершин нашу вершину, из которой будет строится путь
        int pred = 0;                                                                                                   // так как в алгоритме необходим вес пршлой вершины для построения пути, а первая вершина у нас 0, поэтому присваиваем значение 0
        weight[begin] = 0;                                                                                              // записываем на место нашей вершины её вес
        for(int i=0;i < matr.length;i++){                                                                               // заполняем 1 строку матрицы 0 и 1000, для того, чтобы на последующих итерациях могли сравнивать значения и находить минимальное
            if(i == begin){
                matr[0][i] = 0;
            }else{
                matr[0][i] = 10000;
            }
            p[0][i]=-1;
        }
        int min;                                                                                                        // переменная для нахождения минимального элемента в строке (смотрите алгоритм Дейкстры)
        int index=0;                                                                                                    // индекс минимальной вершины, чтобы записать ей в список посещенных и массив весов
        for(int i=1;i<g.length;i++){
            for(int j=0;j<g.length;j++){
                p[i][j]=p[i-1][j];                                                                                      // копируем предыдущую строку матрицы путь на новую, для того чтоб не терять значения прошлых вершин
                if(availability(j,here)==true){                                                                         // проверяет были ли мы в данной вершине и чтоб больше к ней не возвращаться присваивается значение 1000 (бесконечность)
                    matr[i][j] = 10000;
                }else{
                    if(min(matr[i-1][j],pred+g[here.get(i-1)][j])==true){                                            // нахождение минимального пути сравниваем прошлого значения и значения (вес вершины в которой мы сейчас + вес вершины в которуею переёдем)
                        matr[i][j] = matr[i-1][j];                                                                      // записываем новое, минимальное значение
                        p[i][j] = p[i-1][j];                                                                            // если новый новый путь меньше, то записываем в матрицу пути откуда мы пришли в эту вершину
                    }else{
                        matr[i][j] = pred+g[here.get(i-1)][j];                                                          // записываем предудущее значение
                        p[i][j]=here.get(i-1);                                                                          //
                    }
                }
            }
            min = matr[i][0];
            index = 0;
            for(int c=0;c< matr[i].length;c++){                                                                         // цикл для нахождения минимального значения в строке
                if(matr[i][c]<min){
                    min = matr[i][c];
                    index = c;
                }
            }
            pred = min;                                                                                                 // записываем значение минимального в переменную, для рассмотрения на следующей итерации
            weight[index] = pred;                                                                                       // записываем вес данной вершины
            here.add(index);                                                                                            // обозначаем, что мы уже здесь были и сюда больше цикл не зайдет
        }
        /*for(int i=0;i< matr.length;i++){                                                                              // если необходимоо можно вывести минимальный путь от begin к каждой вершине
            for(int j = 0;j<matr[i].length;j++){
                if(String.valueOf(matr[i][j]).length()==1){
                    System.out.print("    "+matr[i][j]+" ");
                }else if(String.valueOf(matr[i][j]).length()==2){
                    System.out.print("   "+matr[i][j]+" ");
                }else{
                    System.out.print(matr[i][j]+" ");
                }
            }
            System.out.print("\n");
        }*/
        /*for(int i=0;i<p.length;i++){                                                                                  // матрица для отображения пути, как двигались на каждой итерации
            for(int j=0;j<p.length;j++){
                if(String.valueOf(p[i][j]).length()==1){
                    System.out.print(" "+p[i][j]+" ");
                }else if(String.valueOf(p[i][j]).length()==2){
                    System.out.print(p[i][j]+" ");
                }
            }
            System.out.println();
        }*/
        System.out.println();
        for(int i=0;i<path.length;i++){
            path[i] = p[g.length-1][i]+1;                                                                               // последняя строка матрицы пути хранит в себе итоговые значения откуда пришли в заданную ячейку
        }
        path[begin]=0;                                                                                                  // так как begin была начальной вершиной то она равна 0
        while (end1!=begin){                                                                                            // чтоб найти путь к end, необходимо двигаться end->begin
            end1 = path[end1]-1;                                                                                        // извлекаем индекс массива из которого пришли в end и так до тех пор, пока индекс массива не совпадет с begin
            path_+= (end1+1)+"";
        }
        for(int i=path_.length()-1;i>=0;i--){                                                                           // из за того что шли end->begin, а вывод должен быть begin->end, необходимо записывать с конца строки
            itog+=path_.charAt(i)+"->";
        }
        itog+=(end+1)+":"+weight[end];                                                                                  // вывод пути и размера этого пути
        return itog;
    }

    public static boolean availability(int n, ArrayList<Integer> arr){
        for(int i=0;i<arr.size();i++){
            if(arr.get(i)==n){
                return true;
            }
        }
        return false;
    }

    public static boolean min(int x,int y){
        if(x<y)
            return true;
        return false;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(DijkstrasAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(DijkstrasAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(DijkstrasAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(DijkstrasAlgorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new DijkstrasAlgorithm().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    // End of variables declaration//GEN-END:variables
}